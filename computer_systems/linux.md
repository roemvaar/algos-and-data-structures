# Linux

## Kernel Initialization

When the power is applied to an embedded Linux system, a complex
sequence of events is started. After a few tens of seconds, the
Linux kernel is operational and has spawned a series of application
Programs as specified by the system init scripts.

Upon power-on, the bootloader in an embedded system is the first
software to get processor control. After the bootloader has performed
some low-level hardware initialization, control is passed to the Linux
kernel. This can be done in two ways:

1) A manual sequence of events to facilitate development process
2) Automated startup sequence typical of a production environment

## Embedded Linux

Linux kernel is only a small component of an embedded system
based on Linux. In addition to the Linux kernel, you need the
following components to develop, test, and launch your embedded
Linux project:

- A **cross-compiler** and associated **toolchain** for your chosen architecture.
It's a set of tools that compiles source code into executables that can run on
your target device and includes a compiler, a linker, and runtime libraries.


- A **bootloader** ported and configured for your specific hardware platform. 
It's the program that initializes the board and loads the Linux kernel.

- **Linux kernel** which is the heart of the system, managing system resources and
interfacing with hardware.

- A **root filesystem** containing many packages - binary executables and libraries
compiled for your native hardware architecture/processor. Contains libraries and
programs that are run once the kernel has completed its initialization.

Optionally there are other elements, such as:

- **Device drivers** for any custom devices on your board.

- A **device tree** enabled for your particular processor and board. It's a data
structures that describe the device hardware.

- The collection of **programs** specific to your embedded application that makes
the device do whatever it is supposed to do, e.g. display movies, control a robot,
fly a drone, etc.

These are the components of an embedded Linux distribution.

## Selection hardware for embedded Linux

1. A CPU architecture that is supported by the kernel - find them at linux repo at
arch/ directoy, all of them are 32 or 64 bits, and most of them have MMU.

2. A reasonable amount of RAM - 16 MiB is a good minimum.

3. Non-volatile storage - usually flash memory. 8 MiB is enough for a simple device
such as a webcam or a simple router.

4. A serial port is very useful, preferably a UART-based serial port. It doesn't
have to be fitted in production boards, but makes board bring-up, debugging, and
development much easier.

5. You need some means to load software when starting from scratch. JTAG is very
common, but modern SoCs support SD and micro SD cards, or serial interfaces such
as UART or USB.

## Toolchains

It's a set of tools that compiles source code into executables that can run on
your target device and includes a compiler, a linker, and runtime libraries.

Tolchains examples:

  - Based on components from *GNU* project (the majority of Linux systems use this)
  - *Clang* compiler and the associated *Low Level Virtual Machine (LLVM)* project.

As of 2021, GNU toolchain is the most popular and mature toolchain for Linux.

A standard GNU toolchain consists of three main components:

  - Binutils: A set of binary utilities including the assembler and the linker.
  - GNU Compiler Collection (GCC): These are the compilers for C and other
  languages.
  - C library: A standardized application program interface (API) based on POSIX
  specification, which is the main interface to the operating system kernel for
  applications.

Toolchains can be native and cross-toolchains.

Three ways to find a toolchain: 1) ready-built toolchain that matches your needs 2) use a
generated by an embedded build tool (e.g. Yocto or Buildroot) 3) create one yourself

## Drivers

### Char vs Block Drivers

- Char drivers: Character device drivers normally perform I/O in a byte stream.
- Block drivers: Devices that support a file system are known as block devices. Drivers written for these devices are known as block device drivers. 

### Kernel Drivers vs User Space Drivers 

User space driver vs Kernel space driver - checar el pdf de linux-kernel-slides.pdf p.46

## Kernel or Module?

The **kernel image** is a **single file**, resulting from the linking of all
object files that correspond to features enabled in the configuration-

- This is the file that gets loaded in memory by the bootloader
- All included features are therefore available as soon as the kernel starts,
at a time where no filesystem exists

Some features (device drivers, filesystems, etc.) can however be compiled as
**modules**.

- These are plugings that can be laoded/unloaded dynamically to add/remove
features to the kernel
- Each **module is stored as a separate file in the filesystem** (.ko file),
and therefore access to a filesystem is mandatory to use modules.
- This is not posible in the early boot procedure of the kernel, because no
filesystem is available.

## Kernel Compilation Results

- **vmlinux**, the raw uncompressed kernel image, in the ELF format, useful
for debugging purposes, but cannot be booted
- arch/< arch >/boot/*Image, the final, usually compressed, kernel image that
can be booted
  - bzImage for x86, zImage for ARM, Image.gz for RISC-V, vmlinux.bing.gz for
    ARC, etc.
- arch/< arch >/boot/dts/*.dtb, compiled Device Tree files (on some
architectures)
- All kernel modules, spread over the kernel source tree, as .ko (kernel
object) files.
 
 ## Thread vs Process
 
 ## Inter-Process Communication 
 
 ## Synchronization and messaging mechanisms
 
Semaphores, queues, etc.
 
## Application Binary Interface

The calling convention used for passing parameters between function calls. 

For ARM exist the Extended ABI (EABI) and the Extended ABI Hard-Float (EABIHF) which
useas floating point registers. They are incompatible between each other.

## C Library

The programming interface to the Unix operating system is defined in the C language,
which is now defined by the POSIX standards. The **C library** is the implementation
of that interface; it is the gateway to the kernel for Linux programs. Even if you're
writing programs in another language, maybe Java or Python, the respective runtime support
libraries will have to call the C library eventually.

![c_library(./img/c_lib.jpg)

Whenever the C library needs the services of the kernel, it will use the kernel system call
interface to transition between user space and kernel space.

Main options of C libraries:

  - glibc: standard GNU C library. The most complete implementation of the POSIX API
  - musl libc: good choice for systems with a limited amount of RAM and storage
  - uClibc-ng: microcontroller C library
  - eglibc: obsolete, not longer maintained - DON'T USE IT



